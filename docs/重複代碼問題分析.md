# 重複代碼問題分析：依賴注入與組裝機制

## 問題描述

隨著 API 數量增加，需要在 `infra/wiring.py` 中重複編寫大量的工廠函數：

```python
def create_cart_repository(session: Session) -> CartRepository:
    return CartRepositoryImpl(session)

def create_cart_service(session: Session) -> CartService:
    repo = create_cart_repository(session)
    return CartService(cart_repo=repo)

# 新增 Order 時，又要重複寫：
def create_order_repository(session: Session) -> OrderRepository:
    return OrderRepositoryImpl(session)

def create_order_service(session: Session) -> OrderService:
    repo = create_order_repository(session)
    return OrderService(order_repo=repo)

# ... 每個實體都要重複這個模式
```

這種重複模式會導致：
- 代碼冗餘
- 維護成本增加
- 容易出錯
- 違反 DRY（Don't Repeat Yourself）原則

---

## 根本原因分析

### 根本原因 1：缺乏依賴注入容器（DI Container）

#### 問題描述

當前採用**手動依賴注入**方式，每個實體都需要手寫工廠函數，沒有統一的依賴管理機制。

#### 具體表現

```python
# infra/wiring.py
def create_cart_repository(session: Session) -> CartRepository:
    return CartRepositoryImpl(session)

def create_order_repository(session: Session) -> OrderRepository:
    return OrderRepositoryImpl(session)

def create_product_repository(session: Session) -> ProductRepository:
    return ProductRepositoryImpl(session)

# 每個 Repository 都要寫一個工廠函數
# 每個 Service 也要寫一個工廠函數
```

#### 影響

- **代碼重複**：每個實體都需要類似的工廠函數
- **缺乏統一管理**：沒有中央化的依賴註冊機制
- **難以追蹤**：無法統一查看所有依賴關係

#### 理想狀態

應該有一個統一的容器來管理所有依賴：

```python
# 理想：統一的依賴管理
container.register(CartRepository, CartRepositoryImpl)
container.register(OrderRepository, OrderRepositoryImpl)
# 自動處理依賴注入
```

---

### 根本原因 2：缺乏泛型工廠模式

#### 問題描述

沒有通用的 Repository/Service 創建機制，每個實體的創建邏輯都是硬編碼的，無法利用 Python 的動態特性自動創建。

#### 具體表現

```python
# 當前：每個實體都需要特定的工廠函數
def create_cart_repository(session: Session) -> CartRepository:
    return CartRepositoryImpl(session)

def create_order_repository(session: Session) -> OrderRepository:
    return OrderRepositoryImpl(session)
# 模式相同，但無法重用
```

#### 影響

- **無法抽象**：無法提取共同的創建邏輯
- **無法利用動態特性**：Python 的動態特性沒有被充分利用
- **擴展困難**：新增實體時必須手寫代碼

#### 理想狀態

應該有泛型工廠函數：

```python
# 理想：泛型工廠
def create_repository(repository_type: Type[T], session: Session) -> T:
    # 自動找到對應的 Impl 類別並實例化
    impl_class = find_implementation(repository_type)
    return impl_class(session)
```

---

### 根本原因 3：緊耦合的組裝邏輯

#### 問題描述

`wiring.py` 需要明確知道每個實體的具體實作類，新增實體時必須修改 `wiring.py`，違反開閉原則（Open-Closed Principle）。

#### 具體表現

```python
# infra/wiring.py
from app.infra.db.repositories.cart_repository_impl import CartRepositoryImpl
from app.infra.db.repositories.order_repository_impl import OrderRepositoryImpl
from app.infra.db.repositories.product_repository_impl import ProductRepositoryImpl
# 隨著實體增加，導入越來越多

def create_cart_repository(session: Session) -> CartRepository:
    return CartRepositoryImpl(session)  # 硬編碼的實作類

def create_order_repository(session: Session) -> OrderRepository:
    return OrderRepositoryImpl(session)  # 硬編碼的實作類
```

#### 影響

- **違反開閉原則**：新增功能需要修改現有代碼
- **導入爆炸**：隨著實體增加，導入語句越來越多
- **維護困難**：每次新增實體都要修改 `wiring.py`

#### 理想狀態

應該自動發現和組裝：

```python
# 理想：自動發現，無需手動導入
# 自動掃描 infra/db/repositories/ 目錄
# 自動建立 Repository -> RepositoryImpl 映射
# 無需修改 wiring.py
```

---

### 根本原因 4：缺乏約定優於配置（Convention over Configuration）

#### 問題描述

沒有基於命名約定的自動發現機制，必須手動註冊每個組件，無法利用現有的命名約定自動建立映射關係。

#### 具體表現

當前已有良好的命名約定：
- `CartRepository` → `CartRepositoryImpl`
- `OrderRepository` → `OrderRepositoryImpl`
- `CartService` → 依賴 `CartRepository`

但這些約定沒有被自動利用：

```python
# 當前：必須手動建立映射
def create_cart_repository(session: Session) -> CartRepository:
    return CartRepositoryImpl(session)  # 手動指定

# 無法自動發現：CartRepository -> CartRepositoryImpl
```

#### 影響

- **重複勞動**：明明有命名約定，卻要手動建立映射
- **容易出錯**：手動映射可能出錯（如拼寫錯誤）
- **無法擴展**：新增實體時無法自動發現

#### 理想狀態

應該基於命名約定自動發現：

```python
# 理想：自動發現機制
# 掃描 core/repositories/ -> 找到 CartRepository
# 掃描 infra/db/repositories/ -> 找到 CartRepositoryImpl
# 自動建立映射：CartRepository -> CartRepositoryImpl
# 基於命名約定：{Entity}Repository -> {Entity}RepositoryImpl
```

---

### 根本原因 5：Service 的依賴關係複雜度

#### 問題描述

Service 可能依賴多個 Repository/Port，每個 Service 的依賴組合都不同，需要手動組裝所有依賴，複雜度隨依賴數量線性增長。

#### 具體表現

簡單情況（單一依賴）：
```python
class CartService:
    def __init__(self, cart_repo: CartRepository):
        self.cart_repo = cart_repo

# 組裝簡單
def create_cart_service(session: Session) -> CartService:
    repo = create_cart_repository(session)
    return CartService(cart_repo=repo)
```

複雜情況（多個依賴）：
```python
class OrderService:
    def __init__(
        self,
        order_repo: OrderRepository,
        product_repo: ProductRepository,
        payment_port: PaymentPort,
        notification_port: NotificationPort
    ):
        self.order_repo = order_repo
        self.product_repo = product_repo
        self.payment_port = payment_port
        self.notification_port = notification_port

# 組裝複雜，需要手動注入所有依賴
def create_order_service(session: Session) -> OrderService:
    order_repo = create_order_repository(session)
    product_repo = create_product_repository(session)
    payment_port = create_payment_port()
    notification_port = create_notification_port()
    return OrderService(
        order_repo=order_repo,
        product_repo=product_repo,
        payment_port=payment_port,
        notification_port=notification_port
    )
```

#### 影響

- **組裝複雜**：依賴越多，組裝代碼越長
- **容易遺漏**：手動組裝可能遺漏某些依賴
- **難以維護**：依賴關係變更時需要修改多處

#### 理想狀態

應該自動解析依賴：

```python
# 理想：自動解析 __init__ 簽名
# 分析 OrderService.__init__ 的參數
# 自動識別需要的依賴類型
# 自動注入對應的實例
# 無需手動組裝
```

---

## 問題總結

### 核心問題

**缺乏自動化的依賴注入與組裝機制**

### 具體表現

1. **手動工廠函數** → 每個實體都要寫
2. **手動導入** → 新增實體要修改 wiring.py
3. **手動組裝** → Service 依賴複雜時組裝邏輯重複
4. **缺乏抽象** → 無法利用泛型/動態特性
5. **違反原則** → 違反 DRY、開閉原則

### 影響範圍

- **開發效率**：新增實體時需要重複編寫相似代碼
- **代碼質量**：重複代碼增加維護成本
- **擴展性**：隨著實體增加，問題會越來越嚴重
- **可維護性**：修改依賴關係時需要修改多處

---

## 解決方向

### 1. 引入依賴注入容器（DI Container）

使用成熟的 DI 框架（如 `dependency-injector`）來統一管理依賴。

**優點**：
- 功能強大
- 成熟穩定

**缺點**：
- 學習曲線
- 可能過度設計

### 2. 實現泛型工廠

創建通用的工廠函數，利用 Python 的動態特性自動創建實例。

**優點**：
- 輕量級
- 符合 Python 風格

**缺點**：
- 需要實現自動發現邏輯

### 3. 自動發現機制

基於命名約定自動掃描和註冊所有 Repository/Service。

**優點**：
- 約定優於配置
- 無需手動註冊

**缺點**：
- 需要定義清晰的命名約定

### 4. 配置化組裝

使用配置文件定義依賴關係。

**優點**：
- 靈活可配置

**缺點**：
- 需要維護配置
- 容易出錯

### 5. 混合方案（推薦）

**自動發現 + 註冊表模式 + 泛型工廠**

結合多種技術，實現輕量級的自動化依賴注入：

- 自動發現：基於命名約定掃描組件
- 註冊表：統一管理依賴映射
- 泛型工廠：統一的創建函數
- 自動解析：自動解析 Service 的依賴

**優點**：
- ✅ 輕量級，無需引入新框架
- ✅ 符合 Python 風格
- ✅ 保持架構清晰
- ✅ 漸進式改進
- ✅ 易於理解和維護

---

## 參考資料

- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Hexagonal Architecture (Ports and Adapters)](https://alistair.cockburn.us/hexagonal-architecture/)
- [Dependency Injection in Python](https://python-dependency-injector.ets-labs.org/)
- [DRY Principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)
- [Open-Closed Principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)

