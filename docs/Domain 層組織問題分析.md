# Domain 層組織問題分析

## 問題描述

當前 Domain 層的組織方式雖然按聚合（Aggregate）劃分了目錄，但聚合內部的每個檔案都只是單一模組。當功能累積、業務邏輯變複雜時，單一檔案（如 `order.py`）可能會變得過長，難以管理和維護。

## 根本原因分析

### 1. **組織維度單一化**

**當前設計：**
```
core/domain/
├── cart.py              # 簡單聚合：單一檔案
└── order/               # 複雜聚合：按實體拆分
    ├── order.py         # 聚合根（可能變得很長）
    ├── order_item.py    # 實體
    ├── order_status.py  # 枚舉
    └── shipping_address.py  # 值對象
```

**問題：**
- 只考慮了「聚合」這個組織維度
- 沒有考慮聚合內部可能也需要進一步的組織
- 當 `order.py` 累積大量業務方法時，沒有拆分指導原則

### 2. **缺乏職責分離的指導原則**

**對比 API 層的組織方式：**

```
api/
├── schemas/          # 按職責：資料結構定義
│   └── cart.py
└── utils/
    └── converters/   # 按職責：轉換邏輯
        └── cart.py
```

**API 層的優點：**
- ✅ 明確的職責分離：Schema vs Converter
- ✅ 每個職責都有獨立的組織原則
- ✅ 當某個職責變複雜時，可以進一步拆分

**Domain 層的缺失：**
- ❌ 沒有明確的職責分離指導原則
- ❌ 聚合根可能包含多種職責（狀態管理、計算、驗證等）
- ❌ 當單一職責變複雜時，沒有拆分機制

### 3. **缺乏複雜度管理的分層機制**

**當前架構的分層邏輯：**

| 層級 | 組織原則 | 拆分觸發條件 |
|------|---------|------------|
| **API 層** | 按資源 → 按職責（schemas/converters） | 職責分離 |
| **Service 層** | 按資源（單一檔案） | 未定義 |
| **Domain 層** | 按聚合 → 按實體 | **缺乏進一步拆分機制** |

**問題：**
- Domain 層只有兩層：聚合 → 實體
- 當聚合根變複雜時，沒有第三層的組織機制
- 對比 API 層：資源 → 職責 → 具體實現（三層）

### 4. **實體職責邊界模糊**

**當前 `order.py` 可能包含的職責：**

```python
class Order:
    # 1. 狀態管理
    def confirm(self): ...
    def cancel(self): ...
    def ship(self): ...
    
    # 2. 項目管理
    def add_item(self): ...
    def remove_item(self): ...
    def update_item(self): ...
    
    # 3. 計算邏輯
    def total_amount(self): ...
    def calculate_shipping(self): ...
    def calculate_discount(self): ...
    
    # 4. 驗證邏輯
    def validate_for_checkout(self): ...
    def validate_shipping_address(self): ...
    
    # 5. 業務規則
    def apply_coupon(self): ...
    def apply_promotion(self): ...
```

**問題：**
- 所有職責都混在一個類別中
- 沒有明確的職責邊界
- 當某個職責變複雜時，無法獨立拆分

### 5. **與架構設計原則不一致**

**架構說明中的 Domain 層定義：**

> 定義系統領域模型（Domain Model）與商業規則。

**問題：**
- 「商業規則」是一個廣泛的概念
- 沒有細分不同類型的商業規則（狀態規則、計算規則、驗證規則等）
- 導致所有規則都放在聚合根中

## 對比分析：API 層 vs Domain 層

### API 層的組織優勢

```
api/
├── schemas/              # 職責 1：資料結構
│   └── cart.py
└── utils/
    └── converters/       # 職責 2：轉換邏輯
        └── cart.py
```

**優點：**
1. **職責清晰**：每個目錄有明確的職責
2. **易於擴展**：當轉換邏輯變複雜時，可以進一步拆分
3. **易於測試**：每個職責可以獨立測試

### Domain 層的組織缺失

```
core/domain/
└── order/
    ├── order.py          # 所有職責混在一起
    ├── order_item.py
    └── ...
```

**缺失：**
1. **職責混雜**：狀態管理、計算、驗證都在一個檔案
2. **難以擴展**：當某個職責變複雜時，沒有拆分機制
3. **難以測試**：職責混雜導致測試困難

## 根本原因總結

### 核心問題

**Domain 層的組織原則只考慮了「聚合」這個維度，沒有考慮「職責」這個維度。**

### 具體表現

1. **單一組織維度**：只按聚合和實體拆分，沒有按職責拆分
2. **缺乏職責分離指導**：沒有明確的職責分離原則
3. **缺乏複雜度管理機制**：當單一檔案變複雜時，沒有進一步拆分機制
4. **實體職責邊界模糊**：聚合根可能包含多種職責，沒有明確邊界
5. **與架構原則不一致**：架構說明中沒有細分不同類型的商業規則

### 影響

- ❌ 當聚合根變複雜時，單一檔案會變得過長
- ❌ 職責混雜，難以維護和測試
- ❌ 缺乏擴展性，無法應對複雜業務邏輯
- ❌ 與其他層（如 API 層）的組織方式不一致

## 解決方向建議

### 1. 引入職責分離原則

參考 API 層的組織方式，在 Domain 層也引入職責分離：

```
core/domain/order/
├── order.py              # 聚合根（核心狀態和基本方法）
├── order_item.py         # 實體
├── order_status.py       # 枚舉
├── shipping_address.py   # 值對象
├── order_calculator.py   # 計算邏輯（領域服務）
├── order_validator.py    # 驗證邏輯（領域服務）
└── order_state_machine.py  # 狀態管理（領域服務）
```

### 2. 定義職責邊界

明確不同職責的邊界：
- **聚合根**：核心狀態、基本 CRUD 操作
- **領域服務**：複雜計算、驗證、狀態轉換
- **值對象**：不可變的資料結構
- **實體**：有 ID 的可變對象

### 3. 建立拆分觸發條件

定義何時需要進一步拆分：
- 聚合根方法超過 10 個
- 單一檔案超過 300 行
- 包含多種明顯不同的職責

### 4. 統一組織原則

讓 Domain 層的組織原則與其他層保持一致：
- 都考慮「資源/聚合」和「職責」兩個維度
- 都有明確的拆分機制和觸發條件

## 結論

**根本原因：Domain 層的組織原則只考慮了「聚合」這個維度，缺乏「職責分離」的指導原則，導致當聚合根變複雜時，無法進一步拆分和管理。**

解決這個問題需要：
1. 引入職責分離原則
2. 定義職責邊界
3. 建立拆分觸發條件
4. 統一組織原則，與其他層保持一致

